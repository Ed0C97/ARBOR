# =============================================================================
# A.R.B.O.R. Enterprise - Continuous Deployment
# Deploy to GKE staging (on develop merge) and production (on main merge)
# =============================================================================

name: CD

on:
  push:
    branches:
      - main
      - develop
    paths-ignore:
      - "**.md"
      - "docs/**"
      - ".gitignore"

  # Allow manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - staging
          - production
      version:
        description: "Image tag to deploy (defaults to latest commit SHA)"
        required: false
        type: string

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: false

env:
  REGISTRY: us-central1-docker.pkg.dev
  PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  REPOSITORY: arbor-enterprise-images
  GKE_CLUSTER: arbor-enterprise-gke
  GKE_REGION: us-central1
  NAMESPACE: arbor

jobs:
  # ---------------------------------------------------------------------------
  # Determine deployment target
  # ---------------------------------------------------------------------------
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      image-tag: ${{ steps.set-env.outputs.image-tag }}
      registry-url: ${{ steps.set-env.outputs.registry-url }}
    steps:
      - name: Determine environment and tag
        id: set-env
        run: |
          # Determine environment
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
            TAG="${{ github.event.inputs.version || github.sha }}"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENV="production"
            TAG="${{ github.sha }}"
          else
            ENV="staging"
            TAG="${{ github.sha }}"
          fi

          REGISTRY_URL="${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}"

          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "image-tag=${TAG}" >> $GITHUB_OUTPUT
          echo "registry-url=${REGISTRY_URL}" >> $GITHUB_OUTPUT
          echo "Deploying to ${ENV} with tag ${TAG}"

  # ---------------------------------------------------------------------------
  # Run CI checks before deployment
  # ---------------------------------------------------------------------------
  ci-gate:
    name: CI Gate
    needs: [prepare]
    uses: ./.github/workflows/ci.yml
    secrets: inherit

  # ---------------------------------------------------------------------------
  # Build and push Docker images to Artifact Registry
  # ---------------------------------------------------------------------------
  build-push:
    name: Build & Push Images
    runs-on: ubuntu-latest
    needs: [prepare, ci-gate]
    permissions:
      contents: read
      id-token: write
    strategy:
      matrix:
        include:
          - target: api
            dockerfile: infrastructure/docker/Dockerfile.api
            image-name: arbor-api
          - target: worker
            dockerfile: infrastructure/docker/Dockerfile.worker
            image-name: arbor-worker

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGISTRY }} --quiet

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: buildx-${{ matrix.target }}-${{ github.sha }}
          restore-keys: |
            buildx-${{ matrix.target }}-

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.prepare.outputs.registry-url }}/${{ matrix.image-name }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch
            type=raw,value=${{ needs.prepare.outputs.image-tag }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
          build-args: |
            APP_VERSION=${{ needs.prepare.outputs.image-tag }}

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  # ---------------------------------------------------------------------------
  # Deploy to Staging
  # ---------------------------------------------------------------------------
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [prepare, build-push]
    if: needs.prepare.outputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging-api.arbor.io
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_REGION }}

      - name: Create namespace if not exists
        run: kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy API to staging
        run: |
          IMAGE="${{ needs.prepare.outputs.registry-url }}/arbor-api:${{ needs.prepare.outputs.image-tag }}"

          # Update deployment image
          kubectl set image deployment/arbor-api \
            arbor-api=${IMAGE} \
            run-migrations=${IMAGE} \
            -n ${{ env.NAMESPACE }}

          # Wait for rollout
          kubectl rollout status deployment/arbor-api \
            -n ${{ env.NAMESPACE }} \
            --timeout=300s

      - name: Deploy Worker to staging
        run: |
          IMAGE="${{ needs.prepare.outputs.registry-url }}/arbor-worker:${{ needs.prepare.outputs.image-tag }}"

          kubectl set image deployment/arbor-worker \
            arbor-worker=${IMAGE} \
            -n ${{ env.NAMESPACE }}

          kubectl rollout status deployment/arbor-worker \
            -n ${{ env.NAMESPACE }} \
            --timeout=300s

      - name: Verify staging deployment
        run: |
          echo "Checking pod status..."
          kubectl get pods -n ${{ env.NAMESPACE }} -l part-of=arbor-enterprise

          echo ""
          echo "Checking service endpoints..."
          kubectl get svc -n ${{ env.NAMESPACE }}

          echo ""
          echo "Running health check..."
          API_IP=$(kubectl get svc arbor-api -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -n "$API_IP" ]; then
            for i in $(seq 1 10); do
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://${API_IP}/health" || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "Health check passed (HTTP ${HTTP_CODE})"
                break
              fi
              echo "Attempt ${i}: HTTP ${HTTP_CODE}, retrying in 10s..."
              sleep 10
            done
          else
            echo "Warning: LoadBalancer IP not yet assigned"
          fi

      - name: Post deployment summary
        if: always()
        run: |
          echo "## Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** ${{ needs.prepare.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # Deploy to Production
  # ---------------------------------------------------------------------------
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [prepare, build-push]
    if: needs.prepare.outputs.environment == 'production'
    environment:
      name: production
      url: https://api.arbor.io
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_REGION }}

      - name: Pre-deployment snapshot
        run: |
          echo "Current deployment state:"
          kubectl get deployments -n ${{ env.NAMESPACE }} -o wide
          echo ""
          kubectl get pods -n ${{ env.NAMESPACE }} -l part-of=arbor-enterprise

      - name: Deploy API to production (canary)
        run: |
          IMAGE="${{ needs.prepare.outputs.registry-url }}/arbor-api:${{ needs.prepare.outputs.image-tag }}"

          # Update deployment image
          kubectl set image deployment/arbor-api \
            arbor-api=${IMAGE} \
            run-migrations=${IMAGE} \
            -n ${{ env.NAMESPACE }}

          # Annotate deployment
          kubectl annotate deployment/arbor-api \
            -n ${{ env.NAMESPACE }} \
            kubernetes.io/change-cause="Deploy ${IMAGE} by ${{ github.actor }} via commit ${{ github.sha }}" \
            --overwrite

          # Wait for rollout with extended timeout for production
          kubectl rollout status deployment/arbor-api \
            -n ${{ env.NAMESPACE }} \
            --timeout=600s

      - name: Production health gate
        run: |
          echo "Running production health checks..."
          API_IP=$(kubectl get svc arbor-api -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          HEALTHY=false
          for i in $(seq 1 15); do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://${API_IP}/health" || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Health check passed on attempt ${i} (HTTP ${HTTP_CODE})"
              HEALTHY=true
              break
            fi
            echo "Attempt ${i}/15: HTTP ${HTTP_CODE}, retrying in 15s..."
            sleep 15
          done

          if [ "$HEALTHY" != "true" ]; then
            echo "Health checks failed - initiating rollback"
            kubectl rollout undo deployment/arbor-api -n ${{ env.NAMESPACE }}
            kubectl rollout status deployment/arbor-api -n ${{ env.NAMESPACE }} --timeout=300s
            exit 1
          fi

      - name: Deploy Worker to production
        run: |
          IMAGE="${{ needs.prepare.outputs.registry-url }}/arbor-worker:${{ needs.prepare.outputs.image-tag }}"

          kubectl set image deployment/arbor-worker \
            arbor-worker=${IMAGE} \
            -n ${{ env.NAMESPACE }}

          kubectl annotate deployment/arbor-worker \
            -n ${{ env.NAMESPACE }} \
            kubernetes.io/change-cause="Deploy ${IMAGE} by ${{ github.actor }} via commit ${{ github.sha }}" \
            --overwrite

          kubectl rollout status deployment/arbor-worker \
            -n ${{ env.NAMESPACE }} \
            --timeout=600s

      - name: Verify production deployment
        run: |
          echo "=== Production Deployment Status ==="
          echo ""
          echo "Deployments:"
          kubectl get deployments -n ${{ env.NAMESPACE }} -o wide
          echo ""
          echo "Pods:"
          kubectl get pods -n ${{ env.NAMESPACE }} -l part-of=arbor-enterprise
          echo ""
          echo "Services:"
          kubectl get svc -n ${{ env.NAMESPACE }}
          echo ""
          echo "HPA:"
          kubectl get hpa -n ${{ env.NAMESPACE }}

      - name: Post deployment summary
        if: always()
        run: |
          echo "## Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** production" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** ${{ needs.prepare.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Rollback Command" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "kubectl rollout undo deployment/arbor-api -n ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "kubectl rollout undo deployment/arbor-worker -n ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # Post-deployment notifications
  # ---------------------------------------------------------------------------
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [prepare, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result != 'skipped' || needs.deploy-production.result != 'skipped')
    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.deploy-staging.result }}" = "success" ] || [ "${{ needs.deploy-production.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=white_check_mark" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=x" >> $GITHUB_OUTPUT
          fi

      - name: Post summary
        run: |
          echo "## Deployment Notification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ${{ steps.status.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ needs.prepare.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag:** ${{ needs.prepare.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
